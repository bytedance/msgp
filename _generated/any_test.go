package _generated

// Code generated by github.com/henrylee2cn/msgp DO NOT EDIT.

import (
	"bytes"
	"encoding/json"
	"testing"

	"github.com/henrylee2cn/msgp/msgp"
)

func TestMarshalUnmarshalTable2(t *testing.T) {
	v1 := Table{
		A: &GridView{"0000"},
		B: [5]msgp.Any{
			&GridView{"1111"},
			&GridView{"2222"},
			&GridView{"3333"},
			&GridView{"4444"},
		},
		C: []msgp.Any{
			&GridView{"5555"},
			&GridView{"6666"},
		},
		D: map[string]msgp.Any{
			"aaaa": &GridView{"7777"},
			"bbbb": &GridView{"8888"},
		},
		E: map[string][]msgp.Any{
			"cccc": {&GridView{"9999"}},
		},
	}
	b1, _ := json.Marshal(v1)
	t.Logf("send table: %s", b1)

	bts, err := v1.MarshalMsg(nil)
	if err != nil {
		t.Fatal(err)
	}
	v2 := Table{}
	left, err := v2.UnmarshalMsg(bts)
	if err != nil {
		t.Fatal(err)
	}
	if len(left) > 0 {
		t.Errorf("%d bytes left over after UnmarshalMsg(): %q", len(left), left)
	}
	b2, _ := json.Marshal(v2)
	t.Logf("recv table: %s", b2)

	left, err = msgp.Skip(bts)
	if err != nil {
		t.Fatal(err)
	}
	if len(left) > 0 {
		t.Errorf("%d bytes left over after Skip(): %q", len(left), left)
	}
}

func TestEncodeDecodeTable2(t *testing.T) {
	v1 := Table{
		A: &GridView{"0000"},
		B: [5]msgp.Any{
			&GridView{"1111"},
			&GridView{"2222"},
			&GridView{"3333"},
			&GridView{"4444"},
		},
		C: []msgp.Any{
			&GridView{"5555"},
			&GridView{"6666"},
		},
		D: map[string]msgp.Any{
			"aaaa": &GridView{"7777"},
			"bbbb": &GridView{"8888"},
		},
		E: map[string][]msgp.Any{
			"cccc": {&GridView{"9999"}},
		},
	}
	b1, _ := json.Marshal(v1)
	t.Logf("send table: %s", b1)

	var buf bytes.Buffer
	msgp.Encode(&buf, &v1)

	m := v1.Msgsize()
	if buf.Len() > m {
		t.Logf("WARNING: Msgsize() for %v is inaccurate", v1)
	}

	vn := Table{}
	err := msgp.Decode(&buf, &vn)
	if err != nil {
		t.Error(err)
	}
	bn, _ := json.Marshal(vn)
	t.Logf("recv table: %s", bn)

	buf.Reset()
	msgp.Encode(&buf, &v1)
	err = msgp.NewReader(&buf).Skip()
	if err != nil {
		t.Error(err)
	}
}
